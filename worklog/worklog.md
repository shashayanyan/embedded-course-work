# Introduction

This is **your worklog** when discovering programming for embedded systems. 
It should contain what you will need to reopen this project in 6 months 
or a year and be able to understand and evolve it.

Also, as an Appendix, there should be the necessary details about what is
new to you, something like a cheat sheet in some sense. Something you can 
go back to when your memory will not server you well.

# First Sprint

## [Setup](./setup.md)
A simple terminal(?) where you can see whatever key you type
correction: not every ASCII is visible here
A C Makefile for early bachelor's courses PTSD
## [Understanding the build](./build.md)
- The configuration of the `GNU` toolchain and `QEMU` should be correlated to ensure the compiled code is compatible with the emulated hardware. This correlation involves matching the target CPU archi and the machine type. They are correlated through shared variables like `GCPU/QCPU` (both set to cortex-a8) and `MACHINE` (set to versatilepb) for the board type.
- linker script sections
    - `.text` for executable code (starting at 0x0 for exceptions, then 0x1000 for main code), 
    - `.data` for initialized
  variables, 
    - `.bss` for uninitialized data (which is zeroed at startup), and a 4KB region for the C stack (growing downwards).
- The linker script is **versatile** specific because it uses hardcoded memory addresses and section sizes (for example 0x0, 0x1000, 4KB stack) tailored to the memory map and architecture of the Versatile Application Baseboard, and explicitly references object files compiled for this target board.
- Based on the guide documentation the amout of the memory and section placements are correct.
- Compiler flags:
    - `-D$(CPU) -DMEMORY="($(MEMSIZE)*1024)"`: Define preprocessor macros like CORTEX_A8 and MEMORY (total memory size in bytes) for conditional compilation and to inform C code about hardware specifics.
   - `-nostdlib -ffreestanding`: These flags indicate a freestanding environment (no operating system) and prevent linking against standard system libraries, giving full control over the runtime environment essential for embedded systems.
   - `-MT \$@ -MMD -MP -MF $(BUILD)/\$*.d`: These flags instruct GCC to generate dependency files (.d files) that track header file inclusions, enabling make to automatically recompile source files when their dependencies change.
    - `-include \$(wildcard \$(BUILD)/*.d)` dynamically includes all .d files generated by the compiler from the build directory which ensures that the Makefile is aware of header file changes and recompiles only the necessary source files.
- Linker flags
    - `-g` adds debugging information. 
    - `-T versatile.ld` specifies the custom linker script. 
    - `-nostdlib` prevents linking with standard system libraries,
     crucial for embedded environments. 
    - `-static` ensures all necessary code is included directly in the executable without relying on external dynamic libraries.
- The `-g` flag instructs both the **compiler and linker** to include symbolic debugging information in the object files and the final executable. It is not necessary for the code to execute. It only adds debugging metadata
## [Understanding the execution](./execution.md)
- the `exception` vector in `exception.s` is a table of addresses at the start of memory (0x0). it directs the processor to specific handler routines for different exception types like reset, undefined instruction, software interrupt, aborts, and hardware interrupts. Most handlers are basic loops.
- It is a critical boot-up task, iterating through the memory region defined `by _bss_start` and `_bss_end` and zeroing out its contents. This ensures that all uninitialized global and static variables, which reside in the `.bss` section, are set to zero before the C code begins execution
- the stack is for managing function calls, local variables, and return addresses in a C program
- It is initialized to 4KB (`stack_top`) and grows downwards.
- The loop in `main` constantly polls UART0 to fill the variable c with it. Once there is something new in it to put in c, it checks the new value in c. If it's the carriage return, it goes to the beginning of the line and goes to a new line. Otherwise it puts what's in c where the cursor is pointing.
- 8-bit ASCII encoded characters are flowing back and forth through `UART0`.
- The **Zzzz....** signifies that, since the beginning of the code or the last Zzzz.... printed, there have been a cumulated 50000000 loop cycles where there has not been a character input in the terminal window. It also means that the system is in busy-waiting.
## [Advanced debugging](./debugging.md)
- This file walked me through debugging for bare-metal with GDB. `breakpoints` are same like normal linux but with a limit on quantity. I also noted that how much valuable memory a code as simple as kprintf can consume. 
- During the debuggin, we manually triggered a data abort and looked at addresses informing on exceptions, although I'm still not sure I understood that correctly.

# Console
## Terminal Discovery
I didn't know anything about control sequences in terminal, quite interesting. Although it took me a while to find out exactly what these are on my azerty keyboard that I use qwerty on, and then to use them in the program's terminal.

## Implementation
- the base implementation is quite straightforward, knowing the sequences and combining the functions quickly allows us to imlpement the simple console.
- the blinking cursor and the callback funtion are also simple to use, but I needed to look again to remember the function passing syntax in c.
- Now the console has a star cursor and Davinci encryption.

# Event-Driven Scheduler
- The old `while(1)` super-loop in `main.c` was getting a bit messy, mixing the cursor animation with keyboard polling. Plus, it was busy-waiting all the time, which isn't great.
- So, I refactored the whole thing to use a basic event-driven scheduler, like the one from the lecture slides. The idea is to break tasks into small, non-blocking "reactions". I created `event.c` to manage a simple queue of these reactions in a static array. The new `event_loop()` function picks the next ready event and runs it. A key choice is that if there's nothing to do, it tells the CPU to idle with a `wfi` (Wait For Interrupt) instruction instead of spinning uselessly. I got a bit confused with the `sleep_until_next_event()` in the slides and found htis as a solution with the help of google's gen ai gemini.
- The old logic from the main loop was split into two reactions: `poll_uart_reaction` for checking the keyboard and `animate_cursor_reaction` for the blinking cursor. Each one re-schedules itself by re-posting to the event queue.
- A big assumption here is the timer. The `time_now()` function is just a placeholder software counter for now. 
- Also a note on the event queue, it is not a sorted array for now just because I find it easier to implement this way. I might make it a sorted array if I see that it is causing problems in later stages.